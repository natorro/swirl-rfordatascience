- Class: meta
  Course: swirl-rfordatascience
  Lesson: 17_iteration_with_purrr
  Author: your name goes here
  Type: Standard
  Organization: your organization's name goes here
  Version: 2.4.3

- Class: text
  Output: Ahora pasaremos a trabajar con la sentencia for, esta sentencia es un bucle, el cual nos permite repetir una sentencia en un periodo definido, en R tenemos diferentes funcionalidades para las cuales aplicamos un for.

- Class: text
  Output: Por ejemplo si necesitamos checar la meia de diferentes valores dentro de un data frame podemos usar la funció median() para cada valor, pero esto esta mal empleado, la forma más efectiva y eficaz es aplicar un bucle.

- Class: text
  Output: Por ésta misma razón, hablaremos de cuatro variaciones básicas para implementar un bucle, la primera es para modificar un objeto de R que ya existe, el segundo para nombres o vaores, en vez de indices, también lo podemos utilizar para un analisis de salidas cuando no sabemos su longitud, así mismo la manipulación de secuencias.


- Class: cmd_question
  Output: Primero cargaremos la librería tidyverse 
  CorrectAnswer: library(tidyverse)
  AnswerTests: omnitest(correctExpr='library(tidyverse)')
  Hint: Type a hint.


- Class: cmd_question
  Output: Ahora construiremos una tabla con tibble que es la siguiente df <- tibble(a = rnorm(10), b = rnorm(10), c = rnorm(10), d = rnorm(10))
  CorrectAnswer: df <- tibble(a = rnorm(10), b = rnorm(10), c = rnorm(10), d = rnorm(10))
  AnswerTests: omnitest(correctExpr='df <- tibble(a = rnorm(10), b = rnorm(10), c = rnorm(10), d = rnorm(10))')
  Hint: Revisa la sintaxis para generar el tibble.

- Class: text
  Output: Lo que haremos es modificar el data frame con el valor de 3 en todas las columnas



- Class: cmd_question
  Output: La sintaxis es de la siguiente manera for(i in seq_along(df)){df[i] <- 3}
  CorrectAnswer: for(i in seq_along(df)){df[i] <- 3}
  AnswerTests: omnitest(correctExpr='for(i in seq_along(df)){df[i] <- 3}')
  Hint: Revisa la sintaxis del for 

- Class: text
  Output: Si nosotros creamos una salida con nombres, tenemos que asegurarnos de nombrar el vector de resultado.

- Class: cmd_question
  Output: Asi de la siguiente manera queda la funsión r <- vector("lista_salida", length(x))
  CorrectAnswer: r <- vector("lista_salida", length(x))
  AnswerTests: omnitest(correctExpr='EXPR', correctVal=VAL)
  Hint: verifica si la sintaxis es correcta 

- Class: text
  Output: Para hacer un recorrido de los nombres de las columnas de un data frame y ver cuantos son, utilizaremos un bucle para saber el ancho del data frame, esto nos ayudará, para cuando trabajemos con un data frame muy grande.

- Class: cmd_question
  Output: Ahora bien para poder realizar este recorrido de nombres, lo primero que tendremos que hacer es cargar un data frame que tiene R el cual es iris, para cargarlo escribe data("iris")
  CorrectAnswer: data("iris")
  AnswerTests: omnitest(correctExpr='data("iris")')
  Hint: vamos tú puedes.

- Class: cmd_question
  Output: Una vez cargado el data frame de iris, pasareos a realizar la función for( i in seq_along(iris)){nombre[[i]] <- iris [i]}
  CorrectAnswer: for( i in seq_along(iris)){nombre[[i]] <- iris [i]}
  AnswerTests: omnitest(correctExpr='for( i in seq_along(iris)){nombre[[i]] <- iris [i]}')
  Hint: vamos tú puedes.

- Class: cmd_question
  Output: Ahora veremos los levels del data frame para eso en otro for aplicamos la sentencia for(i in seq_along(iris)){valor <- ris[[i]]}
  CorrectAnswer: for(i in seq_along(iris)){valor <- ris[[i]]}
  AnswerTests: omnitest(correctExpr='for(i in seq_along(iris)){valor <- ris[[i]]}')
  Hint: vamos tú puedes.

- Class: text
  Output: Si en dado caso de que nosotros no tengamos conocimiento de las salidas de ciertos datos utilizaremos la función while, esta iteración no para hasta que se cumple una condición. Para ejemplificar esto calcularemos el valor de pi

- Class: cmd_question
  Output: Para esto ocuparemos el data frame iris y veremos su longitud la sentencia sería while(i <= length(iris)){i <- i + 1}
  CorrectAnswer: while(i <= length(iris)){i <- i + 1}
  AnswerTests: omnitest(correctExpr='while(i <= length(iris)){i <- i + 1}')
  Hint: Revisa la sintaxis.

- Class: text
  Output: Si por alguna razón quisieras saber la media de una columna específica del data frame podemos hacer este calculo de dos maneras, la primero por un for y la segunda mediante funciones

- Class: cmd_question
  Output: Para representa la primera mediante el for, primero crearemos el mismo df que trabajamos con los numeros aleatorios, df <- tibble( a = rnorm(10), b = rnorm(10), c = rnorm(10), d = rnorm(10))
  CorrectAnswer: df <- tibble( a = rnorm(10), b = rnorm(10), c = rnorm(10), d = rnorm(10))
  AnswerTests: omnitest(correctExpr='df <- tibble( a = rnorm(10), b = rnorm(10), c = rnorm(10), d = rnorm(10))')
  Hint: No es dificil, vamos tú puedes.

- Class: cmd_question
  Output: Ahora definimos una variable de salida a la cual le pasaremos un vector del tamaño del df  salida <- vector("double", length(df))
  CorrectAnswer: salida <- vector("double", length(df))
  AnswerTests: omnitest(correctExpr='salida <- vector("double", length(df))')
  Hint: No es dificil, vamos tú puedes.

- Class: cmd_question
  Output: Ahora calcularemos la media con todos los valores  for(i in seq_along(df)){salida[[i]] <- mean(df[[i]])}
  CorrectAnswer: for(i in seq_along(df)){salida[[i]] <- mean(df[[i]])}
  AnswerTests: omnitest(correctExpr='for(i in seq_along(df)){salida[[i]] <- mean(df[[i]])}')
  Hint: No es dificil, vamos tú puedes.

- Class: cmd_question
  Output: Para visualizarlo escribe  salida
  CorrectAnswer: salida
  AnswerTests: omnitest(correctExpr='salida')
  Hint: No es dificil, vamos tú puedes.

- Class: text
  Output: Primero, la programaciń funcional, de forma simple es cuando una función admite otra como argumento, por ejemplo la función sapply

- Class: cmd_question
  Output: Escribe cuadrado <- function(x) if(x < 5) x**2 lse -x**2 
  CorrectAnswer: cuadrado <- function(x) if(x < 5) x**2 lse -x**2
  AnswerTests: omnitest(correctExpr='cuadrado <- function(x) if(x < 5) x**2 lse -x**2')
  Hint: Revisa la sintaxis 

- Class: cmd_question
  Output: Comprobamos  sapply(1:10, cuadrado)
  CorrectAnswer: sapply(1:10, cuadrado)
  AnswerTests: omnitest(correctExpr='sapply(1:10, cuadrado)')
  Hint: Revisa la sintaxis 

- Class: text
  Output: La programación funcional la podemos aplicar en grupos homoéneos de valores.

- Class: text
  Output: También podemos contar con las funciones de mapeo, tales como map(), map_lgl(), map_int(), map_dbl(), map_chr()

- Class: text
  Output: la función map() se utiiza para mapear listas, map_lgl() mapea vectores de tipo lógico, map_int() mapea un vector de tipo entero, map_dbl() mapea un vector de tipo ouble y map_chr  mapea un vector de tipo caracter.

- Class: cmd_question
  Output: Para calcular  la media de los datos con la función map hacemos lo siguiente  map_dbl(df, mean)
  CorrectAnswer:  map_dbl(df, mean)
  AnswerTests: omnitest(correctExpr=' map_dbl(df, mean)')
  Hint: Revisa si es correcta la sintaxis 


- Class: cmd_question
  Output: Otra representación equivalente es df %>% map_dbl(mean)
  CorrectAnswer: df %>% map_dbl(mean)
  AnswerTests: omnitest(correctExpr='df %>% map_dbl(mean)')
  Hint: Revisa si es correcta la sintaxis 


- Class: text
  Output: Al momento de hacer una función podemos colocar atajos dentro de las mismas declaraciones de las funciones, esto con el proposito de crear un código más limpio.

- Class: text
  Output: PAra comenzar, ocuparemos el dataset mtcars, y lo que haremos es enlistar los modelos de los automoviles de acuerdo a su tipo de cilindrage, por lo tanto cada una de estas listars por cilindarge, conendrá más listas en las cuales se dará el modelo, el tipo de la variable y su valor.

- Class: cmd_question
  Output: Lo primero que harás es escribir la siguiente funsión modelos <- mtcars %>% split(.$cyl) %>% map(function(df) lm(mpg ~ wt, data = df))
  CorrectAnswer: modelos <- mtcars %>% split(.$cyl) %>% map(function(df) lm(mpg ~ wt, data = df))
  AnswerTests: omnitest(correctExpr='modelos <- mtcars %>% split(.$cyl) %>% map(function(df) lm(mpg ~ wt, data = df))')
  Hint:  Vamos tú puedes 

- Class: text
  Output: Ahora podemos construir la misma función, pero aplicando los atajos que nos permiten compactar el código y que se vea más presentable.

- Class: cmd_question
  Output: La función equivalente a la anterior pero con los atajos es la siguinete modelos <- mtcars %>% split(.$cyl) %>% map(~lm(mpg ~ wt, data = .))
  CorrectAnswer: modelos <- mtcars %>% split(.$cyl) %>% map(~lm(mpg ~ wt, data = .))
  AnswerTests: omnitest(correctExpr='modelos <- mtcars %>% split(.$cyl) %>% map(~lm(mpg ~ wt, data = .))')
  Hint: Intentalo de nuevo, no se te olvide ejecutar la función 

- Class: text
  Output: Como puedes observar es exactamente lo mismo, solo que ahora la función es más corta. 

- Class: text
  Output: Para tratar con los datos en los cuales tenemos errores, ya sea al momento de que estamos trabajandocon los data frame o antes de tratarlos para ver los posibles errores que nos puedan arrojar. 

- Class: cmd_question
  Output: Para ilustrar lo anterior considerece que tenemos la siguiente lista prueba.1 <- safely(long)
  CorrectAnswer: prueba.1 <- safely(long)
  AnswerTests: omnitest(correctExpr='prueba.1 <- safely(long)')
  Hint: Es bastante simple.

- Class: cmd_question
  Output: Ahora consultaremos el contenido de la ista con str  y lo pondremos como paramero el valor safe_long(10)
  CorrectAnswer: str(safe_long(10))
  AnswerTests: omnitest(correctExpr='str(safe_long(10))')
  Hint:  El resultado correcto es str(safe_long(10))

- Class: text
  Output: la función safely() Lo que devuleve es un listado de los resultados y errores de los componentes.

- Class: text
  Output: Entonces practicamente al momento de pasarle la función los valores en los cuales se revisa su estado, si este es exitoso el resultado, los errores son nulos, y si no, pondrá el NA de resultados y los errores que se deben atender.

- Class: cmd_question
  Output: Ahora veremos un ejemplo en el cual se ponen en NULL los resultados y se enlistan los errores escribe str(safe_long("a"))
  CorrectAnswer: str(safe_long("a"))
  AnswerTests: omnitest(correctExpr='str(safe_long("a"))')
  Hint: Revisa la sintaxis.

- Class: cmd_question
  Output: También podemos usar la función de mapeo para visualizar los errores posibles en el contenido de un vctor, por lo tanto escribe un vector que contenga "chucho", 10 y 20 y que esten guardados en la variable x
  CorrectAnswer: x <- c("chucho", 10 , 20)
  AnswerTests: omnitest(correctExpr='x <- c("chucho", 10 , 20)')
  Hint: El vector pedido es x <- c("chucho", 10 , 20)

- Class: cmd_question
  Output: Ahora bien, escribe la siguiente linea de código x.2 <- x %>% map(safely(log))
  CorrectAnswer: x.2 <- x %>% map(safely(log))
  AnswerTests: omnitest(correctExpr='x.2 <- x %>% map(safely(log))')
  Hint: El vector pedido es x.2 <- x %>% map(safely(log))

- Class: cmd_question
  Output: Finalmente usa la función str para viualizar el mapeo de errores 
  CorrectAnswer: str(x.2)
  AnswerTests: omnitest(correctExpr='str(x.2)')
  Hint: El vector pedido es str(x.2)

- Class: text
  Output: Si nosotros queremos tener solo una lista de errores, contamos con la función de transpose(), esta función conjunta en una sola variable todos los resultados y en otra todos los errores encontrados.



- Class: cmd_question
  Output: Con el mismo vetor creado anteriormente, lo que harmos es crear solo una variable de resultados y otra de errores. Entonces a la variable y modificala con la funció transpose().
  CorrectAnswer: y %>% transpose()
  AnswerTests: omnitest(correctExpr='y %>% transpose()')
  Hint: La modificación es y <- transpose()

- Class: cmd_question
  Output: Ahora para checar la lista que en realidad se modifico aplicamos la función str() que anteriormente trabajamos.
  CorrectAnswer: str(y)
  AnswerTests: omnitest(correctExpr='str(y)')
  Hint: La modificación es str(y)

- Class: text
  Output: En algun momento, lo que nos importará es capturar los mensajes de salida, las salidas como tal, y los mensajes de warning

- Class: cmd_question
  Output: Por lo tanto crea una lista de tipo numerica list(2,6,9), y guardala en la variable x.prueba
  CorrectAnswer: x.prueba <- list(2, 6, 9)
  AnswerTests: omnitest(correctExpr='x.prueba <- list(2, 6, 9)')
  Hint: Escribe lo que se te pide.

- Class: cmd_question
  Output: Recopilaremos la información de las salidas,a continuación modifica la variable x.prueba, para mapear las salidas, para esto utiliza la función map() y dentro la función quietly(log)
  CorrectAnswer: x.prueba %>% map(quietly(log))
  AnswerTests: omnitest(correctExpr='x.prueba %>% map(quietly(log))')
  Hint: Escribe lo que se te pide.

- Class: cmd_question
  Output: Por ultimo verifica la información que se recopilo anteriormente con la función que hemos venido trabajando para consultar las listas
  CorrectAnswer: str(x.prueba) 
  AnswerTests: omnitest(correctExpr='str(x.prueba) ')
  Hint: Escribe lo que se te pide.
