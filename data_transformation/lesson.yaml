- Class: meta
  Course: Ciencia de datos con R
  Lesson: data_transformation
  Author: your name goes here
  Type: Standard
  Organization: your organization's name goes here
  Version: 2.4.3


- Class: text
  Output: En este capituo nos centraremos en la funcionalidad del paquete dplyr, con esta herramienta se podrá generar nuevas variables o resumenes, renombrar las variables o reordenar las observaciones, entre otras muchas cosas.
          

- Class: cmd_question
  Output: Para visualizar los datos que se analizaran en esta sección escriba "flights"
 
  CorrectAnswer: flights
  AnswerTests: omnitest(correctExpr='flights')
  Hint: Con este conjunto de datos o tambien llamado marco de datos, nos apoyaremos para realizar éstre capitulo

- Class: text
  Output: ¿Cuál es la diferencia de éste conjunto de datos a los demás? A diferencia de los demas conjuntos de datos este, sumarco se ajusta al tamaño de la consola, se imprime de esta manera porque es un tibble. Tibble <- Es un marco de datos, pero ligeramente ajustado para que mejore su funcionamiento en el tidyvers.

- Class: text
  Output: Uno de los conceptos básicos para manejar un conjunto de datos, es el comando filter(). La función nos ayuda a encontrar un grupo de datos en especifico.

- Class: text
  Output: Al momento de hacer una busqueda, le tenemos que pasar los parametros de busqueda,n el primer parametro va el nombre del conjunto de datos analizados, los otros dos parametros son los de busqueda especifica que puede ser por mes, año,etc.
          

- Class: cmd_question
  Output: Escribe la función filter() con parametros que busquen los datos de los vuelos en el mes 1 del día 1.
  CorrectAnswer: filter(flights, month == 1, day == 1)
  AnswerTests: omnitest(correctExpr=' filter(flights, month == 1, day == 1)')
  Hint: Intenta con flights, month == 1, day == 1, pasandolos como parametros

- Class: text
  Output: Como puedes ver, esta función despliega un nuevo marco de un conjunto de datos con las expreciones que fueron especificadas en la función filter(), para guardar este nuevo conjunto de datos lo tenemos que hacer mediante una variable.

- Class: mult_question
  Output: ¿Qué piensas que puede hacer R al guardar los datos en una variable?
  AnswerChoices: Guardar en la variable;Guardar e Imprimir;No se puede guardar un conjunto de datos en una variable
  CorrectAnswer: Guardar en la variable 
  AnswerTests: omnitest(correctExpr='Guarda e la variable')
  Hint: Se guardan en la variable y si lo deceas puedes imprimirlos con solo hacer un llamado a la variable.

- Class: cmd_question
  Output: Si tenemos un conjunto de datos complicados de analizar, lo podemos simplificar en subconjunbtos, esto se logra recordando la ley de morgan !(x & y), de que otra forma lo puedes reprecentar con operadores lógicos?
  CorrectAnswer: Expression or Value
  AnswerTests: any_of_exprs('!x | !y','!(x | y)', '!x & !y')
  Hint: tambié se puede representar como una or "|" o un and "&".

- Class: text
  Output: Una caracteristica importante de R que puede dificultar la comparación es la falta de valores(o valores perdidos "NA"), ya que cualquier operacion con un valor desconocido también será desconocido.

- Class: text
  Output: Para hacer busqueda en el conjunto de datos de un dato vacio, usamos la función is.na(), como parametro recibirá la variable en donde almacenamos los datos que queremos analizar.Este mismo funciona como un parametro de busqueda al utilizar la función filtro.

- Class: text
  Output:  Ejemplo de esto seria filter(df, is.na(x) | x > 1)

- Class: text
  Output: La función arrange funciona igual que filter; a diferencia de filter, arrange reordena las coumnas. utiliza los parametros para ordenar los datos, por ejemplo, si queremos ordenar los datos por año, mes y día, estos tres se los pasamos como parametros a la función si olvidar que primero va el nombre de la variable que contiene los datos que vamos a ordenar.

- Class: text
  Output: Podemos utilizar el parametro desc("nombre de la columna"), para ordenar el conjunto de datos en forma decendente.

- Class: cmd_question
  Output: Con el conjunto de datos de flights usa la función de arrange y ordena la clumna arr_time de forma descendente.
  CorrectAnswer: arrange(flights, desc(arr_delay))
  AnswerTests: omnitest(correctExpr='arrange(flights, desc(arr_delay))')
  Hint: Usa la función arrange y el nombre del conjunto junto con el parametro desc().

- Class: text
  Output: Otra función de ayuda para manipular los datos es *selec(), nos permite acercarnos rápidamente a un subconjunto útil utilizando operaciones basadas en los nombres de las variables del conjunto de datos.

- Class: text
  Output: Bien ahora pasemos a la practica, como en las funciones anteriores, a esta función le puedes pasar como parametros del nombre de las variables de los datos que quieras analizar.

- Class: cmd_question
  Output: Una de las formas para pasar un conjunto de parametros, es pasandolos como una lista. Usando selec() pasa como parametros el año,mes y día en forma de lista.
  CorrectAnswer: selec(flights, year:day)
  AnswerTests: omnitest(correctExpr='selec(flights, year:day)')
  Hint: Utiliza  year:day como segundo parametro y flights como el primer parametro.

- Class: text
  Output: Hay una serie de auxiliares que puedes usar dentro de selec().De los cuales esta starts_with(), este parametro nos busca en el marco de datos, nombres que inicien con las iniciales que nosotros le asignemos; ends_with(), este parametro busca los nombres que terminen con las letras asignadas; contains(), este parametro nos busja las variables o datos que contengan las letras asignadas; matches() este parametro en particular busca variables que contengan la expresión asignada y por ultimo num_range(), nos sirve para buscar variables enlistados.

- Class: text
  Output: Para poder cambiar el nombre de una de las columnas utilizamos la función rename(), pasandole como segundo parametro del nombre al que se quiere cambiar e igualando al existente, ademas concerva todas las variables que no se mencionan explicitamente.


- Class: text
  Output: Si se quiere agregar columanas a las ya existentes, podemos utilizar la funcion mutate(), esta nos permitira agregar nuevas columnas (variables) al conjunto ya existente. antes de usar la función, tenemos que seleccionar los datos en los que vamos a trabajar  y guardarlos en una variable para que este pase a ser el primer parametro de referencia de la función mutate().

- Class: mult_question
  Output: Aparte de agregar las dos columnas,sería posible que a los parametros les asignemos operaciones entre columnas 
  AnswerChoices: si; no
  CorrectAnswer: si
  AnswerTests: omnitest(correctExpr='si')
  Hint: Piensalo e intentalo de nuevo.

- Class: mult_question
  Output: ¿Cómo visualizarias el resultado en el marco de datos, en un conjunto de datos o en un solo resultado?
  AnswerChoices: En un conjunto de datos; En un solo resultado por cada variable agregada
  CorrectAnswer: En un conjunto de datos
  AnswerTests: omnitest(correctExpr='En un conjunto de datos')
  Hint: Se visualizaran en un conjunto de datos por cada variable.
  

- Class: cmd_question
  Output: Escribe la siguiente funcion mutate(flights_sml,gain = arr_delay - dep_delay,speed = distance / air_time * 60)
  CorrectAnswer: mutate(flights_sml,gain = arr_delay - dep_delay,speed = distance / air_time * 60)
  AnswerTests: expr_uses_func('mutate')
  Hint: prueva con mutate(flights_sml,gain = arr_delay - dep_delay,speed = distance / air_time * 60)



- Class: text
  Output: La ultima función es summarize(), ésta función colapsa un marco de datos a una sola fila, por lo regular esta función la complementan con group_by(). Esto hace que cambie completamente el análisis del conjunto de datos completo para indicar grupos individuales.

- Class: text
  Output: Cuando se usan los verbos dplyr en un marco de datos agrupados, se aplicaran automaticamente por grupo.
