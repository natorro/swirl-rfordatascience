- Class: meta
  Course: swirl-rfordatascience
  Lesson: test
  Author: your name goes here
  Type: Standard
  Organization: your organization's name goes here
  Version: 2.4.3

- Class: text
  Output: Una tarea laboriosa para los Cientificos de Datos, es la organizacion de la informacion. En este capitulo trabajaremos con una tecnica llamada tidy data, tener nuestros datos en orden asegura mejores analisis y eficienta los tiempos de trabajo.
  
- Class: cmd_question
  Output: Trabajaremos con la paqueteria tidyverse (contiene dply y tidyr).Ejecuta;library(tidyverse)
  CorrectAnswer: library(tidyr)
  AnswerTests: omnitest(correctExpr='library(tidyverse)')
  Hint: Tal vez tenemos un caracter erroneo

- Class: text
  Output: Recordemos que la informacion puede representarse de varias maneras; ordenada numericamente, alfabeticamente, etc. Pero existen 3 reglas clave para tener nuestros datos tidy y trabajar de la mejor forma con ellos.

- Class: text
  Output: 1.Cada variable tiene su propia columna, 2.cada observacion su propia fila, 3.cada valor su propia celda

- Class: text
  Output: Veremos 2 ejemplos de como organizar la informacion, Observa e imagina como transformarias los datos.
  
- Class: cmd_question
  Output: Ejecuta;head(table1,5) 
  CorrectAnswer: head(table1,5)
  AnswerTests: omnitest(correctExpr='head(table1,5)')
  Hint: head(table1,5)

- Class: cmd_question
  Output: Ejecuta;head(table2,5) (las columnas cases y population ahora viven en la columna type)
  CorrectAnswer: head(table2,5)
  AnswerTests: omnitest(correctExpr='head(table2,5)')
  Hint: head(table2,5)

- Class: text
  Output: Teniendo los datos almacenados y estructurados podemos utilizar herramientas de trabajo mas avanzadas para el analisis de datos. La manipulacion de variables sobre cada columna permite a R trabajar mejor, siendo mas eficiente con los datos vectorizados y una gran cantidad de funciones en R son compatibles con estas estructuras. Las paqueterias ggplot2,dplyr y tidyr estan diseÃ±adas para trabajar con datos tidy.
  
- Class: text
  Output: Investiguemos un poco sobre las paqueterias a usar dplyr y tidyr.

- Class: cmd_question
  Output: Ejecutemos help(dplyr) y veamos un poco su uso general.
  CorrectAnswer: help(dplyr)
  AnswerTests: omnitest(correctExpr='help(dplyr)')
  Hint: help(dplyr)

- Class: cmd_question
  Output: Ahora veamos help(tidyr)
  CorrectAnswer: help(tidyr)
  AnswerTests: omnitest(correctExpr='help(tidyr)')
  Hint: help(tidyr)

- Class: text
  Output: dplyr nos ayuda a manipular los datos y tidyr a transformarlos

- Class: text
  Output: Comenzemos a trabajar con la funcion mutate() del paquete dplyr (Ayuda a la creacion de nuevas columnas en los datos)

- Class: cmd_question
  Output: Veamos un ejemplo.Ejecuta;table1 %>% mutate(rate = cases / population * 10000) (observa que se creo una nueva columna a partir de columnas existentes)
  CorrectAnswer: table1 %>% mutate(rate = cases / population * 10000)
  AnswerTests: omnitest(correctExpr='table1 %>% mutate(rate = cases / population * 10000)')
  Hint: table1 %>% mutate(rate = cases / population * 10000)

- Class: cmd_question
  Output: Otra funcion util es filter() (ayuda a filtrar los datos por alguna condicion logica). Ejecuta;table1 %>% filter(year == 1999) %>% mutate(rate = population * 10) 
  CorrectAnswer: table1 %>% filter(year == 1999) %>% mutate(rate = population * 10) 
  AnswerTests: omnitest(correctExpr='table1 %>% filter(year == 1999) %>% mutate(rate = population * 10) ')
  Hint: table1 %>% filter(year == 1999) %>% mutate(rate = population * 10) 
  
- Class: cmd_question
  Output: Es tu Turno, crea la siguiente manipulacion datos;Con un filtro en los datos table1 donde year sea igual a 2000 y una nueva columna llamada rate y igual a cases * 10
  CorrectAnswer: table1 %>% filter(year == 2000) %>% mutate(rate = cases * 10)
  AnswerTests: omnitest(correctExpr='table1 %>% filter(year == 2000) %>% mutate(rate = cases * 10)')
  Hint: Combina ambas funciones filter y mutate, table1 %>% filter() %>% mutate()

- Class: cmd_question
  Output: Sigamos aprendiendo funciones. count() (agrupa y suma los elementos). Ejecuta;table1 %>% count(year, wt = cases)
  CorrectAnswer: table1 %>% count(year, wt = cases)
  AnswerTests: omnitest(correctExpr='table1 %>% count(year, wt = cases)')
  Hint: table1 %>% count(year, wt = cases)

- Class: text
  Output: Resumen, hemos visto 3 funciones mutate(),filter(),count() del paquete dplyr. En la siguiente liga puedes encontrar mas funciones utiles -"https://www.rstudio.com/wp-content/uploads/2015/03/data-wrangling-spanish.pdf"

- Class: text
  Output: Veamos 2 funciones muy utiles del paquete tidyr (transforma los datos), gather() y spread().

- Class: cmd_question
  Output: Un problema com?n es un conjunto de datos donde algunos de los nombres de columnas no son nombres de variables, sino valores de una variable. Veamos table4a; los nombres de columna 1999 y 2000 representan valores de la variable del a?o, y cada fila representa dos observaciones, no una. Ejecuta; head(table4a)
  CorrectAnswer: head(table4a)
  AnswerTests: omnitest(correctExpr='head(table4a)')
  Hint: head(table4a)

- Class: cmd_question
  Output: La funcion Gather() acomoda las columnas en filas, se colocan los nombres de las columnas que se desear agrupar (argumento key = "nombre que almacena las columnas") y las columnas que quedan como valores (value = "cases"). Ejecuta; table4a %>%  gather(`1999`, `2000`, key = "year", value = "cases") 
  CorrectAnswer: table4a %>%  gather(`1999`, `2000`, key = "year", value = "cases") 
  AnswerTests: omnitest(correctExpr='table4a %>%  gather(`1999`, `2000`, key = "year", value = "cases") ')
  Hint: table4a %>%  gather(`1999`, `2000`, key = "year", value = "cases") 

- Class: cmd_question
  Output: La funcion contraria a gather() es spread() separa las filas y las acomoda en columnas. Ejecuta; head(table2)
  CorrectAnswer: head(table2)
  AnswerTests: omnitest(correctExpr='head(table2)')
  Hint: head(table2)

- Class: cmd_question
  Output: Espeficicando la columna type (valores unicos de las filas), se crearan 2 nuevas columnas (cases y population). Ejecuta; spread(table2, key = type, value = count)
  CorrectAnswer: spread(table2, key = type, value = count)
  AnswerTests: omnitest(correctExpr='spread(table2, key = type, value = count)')
  Hint: spread(table2, key = type, value = count)

- Class: text
  Output: Ahora es tu Turno....

- Class: cmd_question
  Output: Define la siguiente tabla; table4a_gather <- table4a %>% gather('1999','2000', key = "year", value = "cases")
  CorrectAnswer: table4a_gather <- table4a %>% gather('1999','2000', key = "year", value = "cases")
  AnswerTests: omnitest(correctExpr='table4a_gather <- table4a %>% gather(\'1999','2000', key = "year", value = "cases")')
  Hint: table4a_gather <- table4a %>% gather('1999','2000', key = "year", value = "cases")

- Class: cmd_question
  Output: Imprime la tabla.
  CorrectAnswer: table4a_gather
  AnswerTests: omnitest(correctExpr='table4a_gather')
  Hint: table4a_gather

- Class: cmd_question
  Output: Ocupamos la funcion Gather() para cambiar su estructura, regresala a su estructura original (los valores de las filas en columnas y la columna cases como valores)
  CorrectAnswer: spread(table4a_gather, key = year, value = cases)
  AnswerTests: omnitest(correctExpr='spread(table4a_gather, key = year, value = cases)')
  Hint: spread(table4a_gather, key = "columna a separar", value = "columna con los valores")
