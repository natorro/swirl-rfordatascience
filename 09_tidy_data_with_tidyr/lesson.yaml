- Class: meta
  Course: swirl-rfordatascience
  Lesson: 09_tidy_data_with_tidyr
  Author: your name goes here
  Type: Standard
  Organization: your organization's name goes here
  Version: 2.4.3

- Class: text
  Output: Durante este capítulo aprenderas una nueva forma de organizar la información llamada tidy data, se requiere algo de trabajo para ordenar la información de esta forma pero vale la pena.

- Class: text
  Output: Tener la información en este formato nos permite pasar menos tiempo acomodando la  información para representarla de una manera o de otra y pasar más tiempo analizandola. Este capítulo te brindara una introducción practica a lo que es tidy data utilizando herramientas que se encuetran en la paquetería 'tidyr'

- Class: text
  Output: El único prerequisito que se pide es importar la libreria tidyverse con 'library(tidyverse)' ya que la paqueteria 'tidyr' pertence a ella. 

- Class: text
  Output: No es algo nuevo decir que la información se puede presentar de distintas maneras ya sesa ordenando la tabla de acuerdo al alfabeto de cierta columna, de forma ascendente o descendente , etc.

- Class: text
  Output: Existen tres reglas claves para poder decir que una serie de datos es tidy o no 

- Class: text
  Output: 1.- Cada variable tiene su propia columna

- Class: text
  Output: 2.- Cada observación tiene su propia fila

- Class: text
  Output: 3.- Cada valor tiene su propia celda

- Class: text
  Output: Por ende concluimos que las variables están en columnas, las observaciones en filas y los valores están en celdas. 

- Class: text
  Output: Se dice que los tres condiciones anteriores están interrelacionadas por que no se pueden cumplir sólo dos de las tres, el incumplimiento de una en automático anula las otras dos.

- Class: text
  Output: EL contar con esta relación nos permite pasar a un conjunto de instrucciones más simples para trabajar con los datos

- Class: text
  Output: 1.- Poner cada serie de datos en un tibble estructura vista en el capítulo siete

- Class: text
  Output: 2.- Poner cada variable en una columna 

- Class: text
  Output: Pero por que aseguranos de que nuestros datos sean tidy





- Class: text
  Output: 1.- El tener los datos almacenados y estructurados de manera consistente hace que sea  mucho más sencillo aprender las herramientas para trabajarlos, pues tiene una uniformidad subyacente.

- Class: text
  Output: 2.- El tener las variables sobre cada columna hace que r trabaje de una manera más eficiente por su naturaleza de vectorizar, una gran cantidad de funciones en R trabajan directamente con vectores como elementos de entrada. Por lo que transformar datos en formato tidy se facilita.

- Class: text
  Output: Las paqueterías dyplr y ggplot2 están diseñadas para trabajar con datos en formato tidy.




- Class: figure
  Output: Ahora veremos un ejemplo de una tabla con formato tidy, ya esta cargada la librería nycflights , las varaibles x, y y z representan una columna de la tabla,las unimos y generamos una data frame a partir de ellas , la nombramos como w y la imprimimos.
  Figure: data.R
  FigureType: new

- Class: text
  Output: Difundir y Reunir Datos

- Class: text
  Output: Podríamos pensar que las reglas de la tidy data osea información ordenada son muy obvias y hasta podráis llegar a preguntarte si en algún momento vas a llegar a encontrarte con información desordenada, desafortunaamente la mayor parte de los datos que encuentres van a estar desordenados y estas son las razones

- Class: text
  Output: Primero la mayoria de las personas no está familiarizada con la información ordenada 

- Class: text
  Output: Segundo, los datos en general se encontraran ordenados para objetivos diferentes que su análisis, muchas veces es sólo para que sea más fácil ingresar la información.

- Class: text
  Output: Que quiere decir esto, que en la mayor parte de análisis que hagamos, tendremos que hacer un poco de ordenamiento en nuestros datos, hay dos problematicas que nos encontraremos comúnmente.

- Class: text
  Output: 1.- Que una variable se encuentre en más de una columna

- Class: text
  Output: 2.- Que una observación se encuentre en más de una fila.

- Class: text
  Output: Para solucionar esto utilizaremos unas de las funciones más importantes en tidyr que vienen siendo gather para reunir y spread para extender

- Class: text
  Output: Primero veremos Reuniendo con la función Gather -->

- Class: text
  Output: Como se menciono anteriormente los datos pueden estar desordenados, un problema con el que comúnmente nos vamos a encontrar es que en la tabla original de la información haya columnas que en lugar de ser nombres de variables son valores de variables y esto debemos modificarlo.

- Class: text
  Output: En el siguiente ejemplo veremos un tabla que presenta la problemática mencionada y como arreglarla con la función gather.




- Class: text
  Output: Lo que vamos a hacer en este ejercicio será crear una data frame llamada autos_data que no este en formato tidy, esta será generada con tres vectores precargados que son modelo, hp2010 y hp2011



- Class: script
  Output: Realiza lo que se te pidió e imprime la tabla
  AnswerTests: omnitest(correctExpr='autos_data = data.frame(modelo , hp2010 , hp2011)')
  Hint: Usa la función dataframe
  Script: notidy.R

- Class: text
  Output: Como podemos ver esta tabla no está ordenada en el formato requerido puesto que la segunda y tercera columna son valores y no variables

- Class: text
  Output: Ordena la tabla utilizando la función gather e imprimela. 

- Class: text
  Output: Prueba aplicar la función gather de la siguiente manera 'tidydata=gather(autos_data,'hp2010','hp2011', key = 'hpYear',value = 'hp')'

- Class: script
  Output: Realiza lo que se te pidió e imprímelo
  AnswerTests: omnitest(correctExpr='tidydata=gather(autos_data,'hp2010','hp2011', key = 'hpYear',value = 'hp')')
  Hint: Utiliza la función gather
  Script: notidy.R

- Class: text
  Output: Como vimos se reordeno la tabla y los títulos de la columna dos y tres que se convirtieron en valores y se asignaron nombres a las nuevas variables.

- Class: text
  Output: La función spread se utiliza para resolver el problema análogo pero de las filas, es decir cuando tenemos una observación repartida entre varias filas

- Class: text
  Output: Lo primero que haremos para realizar nuestra práctica será generar un data frame llamado fusion con los vectores precargados modelo1, hpyear, tipo, valor.

- Class: script
  Output: Realiza lo que se te pidió.
  AnswerTests: omnitest(correctExpr='fusion = data.frame(modelo1,hpyear,tipo,valor)')
  Hint: Utiliza la función data frame y revisa que hayas escrito correctamente tanto el nombre de la data frame como las columnas 
  Script: notidy.R

- Class: text
  Output: Como puedes ver en la data frame que acabas de crear el modelo fusion del año 2010 se encuentra en dos filas cuando lo correcto para que se encuentre en formato tidy sería que sólo haya un fusion de cierto año por cada fila

- Class: text
  Output: Ahora prueba aplicar la función spread de la siguiente manera 'fusionS = spread(fusion, key = tipo, value = valor)'

- Class: script
  Output: Realiza lo que se te pidió
  AnswerTests: omnitest(correctExpr='fusionS = spread(fusion, key = tipo, value = valor)')
  Hint: Revisa que hayas escrito correctamente la expresión que te proporcionamos
  Script: notidy.R

- Class: text
  Output: Como se puede apreciar al imprimir nuestra nueva tabla, ahora sólo hay un fusion de cada año por fila y hay dos nuevas columnas por lo que nuestros datos han quedado ordenados  

- Class: text
  Output: La siguiente función que veremos es Separation and Pull es decir separación y extracción  

- Class: text
  Output: Ya hemos aprendido ha solucionar cierto tipo de problemas a lo largo de la lección

- Class: text
  Output: Utilizaremos la función separate para cuando tenemos más de un valor de diferentes varaibles en una misma columna separado por algún caracter especial o espacio. Que si bien visulamente se entiende sin mayor problema, analíticamente esto sólo nos arrogaría datos sin sentido.

- Class: text
  Output: Como en ejercicios anteriores generaremos una data frame con un problema que puede ser resuelto con la función en turno , generalo con 'sep = data.frame(modelo1, hpyear, tipoval)' todo ya esta precargado

- Class: script
  Output: Realiza lo que se te pidió
  AnswerTests: omnitest(correctExpr='sep = data.frame(modelo1, hpyear, tipoval)')
  Hint: Escribe lo que se te ordeno
  Script: notidy.R

- Class: text
  Output: Ahora aplicaremos la función separate para arreglar el problema de la tabla , prueba con 'separate(sep, tipoval, into = c('tipo','valor'))'

- Class: script
  Output: Realiza lo que se te pidió
  AnswerTests: omnitest(correctExpr='separate(sep, tipoval, into = c('tipo','valor'))')
  Hint: Escribe lo que se te ordeno
  Script: notidy.R
