- Class: meta
  Course: swirl-rfordatascience
  Lesson: 11_strings_with_stringr
  Author: your name goes here
  Type: Standard
  Organization: your organization's name goes here
  Version: 2.4.3

- Class: text
  Output: Strings con "stringr"

- Class: text
  Output: Durante este capítulo te introduciremos al manejo de strings con R.


- Class: text
  Output: Veremos lo básico de los strings y como crearlos pero nos enfocaremos en las expresiones regulares.


- Class: text
  Output: Estas expresiones son útiles porque por lo general los strings son datos no estructurados o semi estructurados y las expresiones regulares sirven para describir sus patrones.

- Class: text
  Output: Para este capítulo deberas tener instaladas las librerías "tidyverse" y "stringr".

- Class: text
  Output: Conceptos básicos 

- Class: text
  Output: Un string se puede crear ya sea  con comillas simples '' o con comillas dobles "" no hay diferencia en el comportamiento. Te recomendamos que utilices comillas dobles salvo el caso en que quieras incluir comillas dentro del string entonces utilizarás comillas simples afuera y dobles adentro.

- Class: cmd_question
  Output: Genera un string introduciendo el siguiente código string <- "hola"
  CorrectAnswer: string <- "hola"
  AnswerTests: omnitest(correctExpr='string <- "hola"')
  Hint: Escribe lo que se te indico.


- Class: text
  Output: Un ejemplo de comillas dentro de un string sería el siguiente string2 <-'Esto es "Esparta"'

- Class: text
  Output: Sí algunas ves olvidas poner las comillas finales en un string te va mandar error en la consola y se quedará corriendo hasta que lo detengas, esto puedes hacerlo presionando la tecla de esc.

- Class: text
  Output: Si quieres incluir literalmente alguna comilla o algún símbolo puedes utilizar una diagonal invertida "\" para que se ignore el símbolo.

- Class: text
  Output: Al utlilizar la diagonal invertida "\" muchos caracteres adqueiren otra función por ejemplo la \n indica un cambio de línea, \t indica una tabulación otro ejemplo importante es "/u00b5" que sirve para escribir caracteres que nos pertenecen al inglés que funcionan en cualquier plataforma.

- Class: cmd_question
  Output: Se pueden guardar strings dentro de un vector, genera uno escribiendo el siguiente código c("a", "bb", "c").
  CorrectAnswer: c("a", "bb", "c")
  AnswerTests: omnitest(correctExpr='c("a", "bb", "c")')
  Hint: Escribe c("a", "bb", "c").

- Class: text
  Output: Longitud de los strings.

- Class: text
  Output: R contiene muchas funciones para trabajar con strings por default, sin embargo suelen se inconsistentes y por lo tanto difíciles de recordar. Nosotros utilizaremos las funciones de stringr que suelen ser más intuitivas y siempre comiezan con un "str_".

- Class: text
  Output: Una de las funciones más comunes es str_length que te devuelve el número de caracteres que tiene un string. 

- Class: cmd_question
  Output: Para que veas su funcionamiento corre el código str_length(c("a", "bb", "b b", NA))
  CorrectAnswer: str_length(c("a", "bb", "b b", NA))
  AnswerTests: omnitest(correctExpr='str_length(c("a", "bb", "b b", NA))')
  Hint: Escribe str_length(c("a", "bb", "b b", NA))

- Class: text
  Output: Combinar Strings.

- Class: text
  Output: Para hacer esto se utiliza la función str_c()

- Class: text
  Output: Por ejemplo str_c("a", "b") regresaría como output "ab"

- Class: text
  Output: Un caso un poco más avanzado sería str_c("a", "b" , sep = "-") regresaría como output "a-b"

- Class: text
  Output: Es posible combinar multiples caracteres.

- Class: cmd_question
  Output: Corre el siguiente código para que veas un ejemplo str_c("Good ", c("morning", "night")).
  CorrectAnswer: str_c("Good ", c("morning", "night"))
  AnswerTests: omnitest(correctExpr='str_c("Good ", c("morning", "night"))')
  Hint: Escribe lo que se te pidió.

- Class: text
  Output: Como en todas las funciones de R, una ves que comprendes como funciona puedes empezar a hacer combinaciones y experimentar.

- Class: text
  Output: Por ejemplo 

- Class: cmd_question
  Output: Define esta variable nombre_alumno <- "Pepe".
  CorrectAnswer: nombre_alumno <- "Pepe" 
  AnswerTests: omnitest(correctExpr='nombre_alumno <- "Pepe"')
  Hint: Usa este código.

- Class: cmd_question
  Output: Ahora define la variable aprobado <- FALSE
  CorrectAnswer: aprobado <- FALSE
  AnswerTests: omnitest(correctExpr='aprobado <- FALSE')
  Hint: Utiliza el código que se te indicó.

- Class: text
  Output: Tienes definida una variable de tipo character y otro de tipo booleano, lo que vamos a hace en el siguiente ejemplo será combinar la función str_c() con un condicional "if()".

- Class: cmd_question
  Output: Escribe el siguiente código str_c( "Felicidades ", nombre_alumno, " ", if (aprobado) " Aprobaste", if(!aprobado) "podrás cursar de nuevo la materia",".")

  CorrectAnswer: str_c( "Felicidades ", nombre_alumno, " ", if (aprobado) " Aprobaste", if(!aprobado) "podrás cursar de nuevo la materia", ".")
  AnswerTests: omnitest(correctExpr='str_c( "Felicidades ", nombre_alumno, " ", if (aprobado) " Aprobaste", if(!aprobado) "podrás cursar de nuevo la materia", ".")')
  Hint: Utiliza el código que se te proporciono.

- Class: text
  Output: Como viste al tener aprobado como false se cumplio la condición de if(!aprobado).

- Class: text
  Output: En el caso de que aprobado fuera TRUE, se escribiría lo que indica la otra condición.

- Class: text
  Output: Ahora veremos subconjuntos de strings.

- Class: text
  Output: Para obtener un substring utilizaremos la función str_sub().

- Class: text
  Output: Los argumentos que esta recibe son

- Class: text
  Output: un string o conjunto de strings

- Class: text
  Output: start <- el lugar del string donde inicia el subconjunto

- Class: text
  Output: end <- el lugar del string donde termina el subconjunto

- Class: text
  Output: Hagamos un ejercicio sencillo de esto

- Class: cmd_question
  Output: define el siguiente vector color <- c("rojo", "azul", "amarillo")
  CorrectAnswer: color <- c("rojo", "azul", "amarillo")
  AnswerTests: omnitest(correctExpr='color <- c("rojo", "azul", "amarillo")')
  Hint: Utiliza lo que se te dió.

- Class: cmd_question
  Output: Utiliza la función str_sub() para  extraer la primera letra de cada color.
  CorrectAnswer: str_sub(color, start = 1, end = 1)
  AnswerTests: omnitest(correctExpr='str_sub(color, start = 1, end = 1)')
  Hint: Utiliza este código str_sub(color, start = 1, end = 1).

- Class: text
  Output: Existen otras funciones que pueden ser muy útiles como son str_to_lower que sirve para hacer las letras minúsculas o str_to_upper para hacerlas mayúsculas, str_sort para ordenar y str_to_title que hace mayúscula a la primer letra de la palabra.

- Class: cmd_question
  Output: En este ejercicio vas a hacer mayúscula la primer letra de cada color. Deberas utlizar la función str_sub dentro de str_to_upper pero ojo, esto sólo te arrojará los valores que pides, tienes que definir a estás letras como las nuevas letras inciales.
  CorrectAnswer: str_sub(color, 1, 1) <- str_to_upper(str_sub(color, 1, 1))
  AnswerTests: omnitest(correctExpr='str_sub(color, 1, 1) <- str_to_upper(str_sub(color, 1, 1))')
  Hint: Esta es la respuesta correcta str_sub(color, 1, 1) <- str_to_upper(str_sub(color, 1, 1))

- Class: cmd_question
  Output: Escribe color para que veas como quedó el vector.
  CorrectAnswer: color
  AnswerTests: omnitest(correctExpr='color')
  Hint: Escribe color.

- Class: text
  Output: Al aplicar funciones como str_to_upper, str_to_lower, str_to_title o str_sort es importante considerar el idioma con el que estamos trabajando ya que cada lenguaje tiene sus propias reglas.

- Class: text
  Output: Afortunadamente a cada una de estas funciones se le puede agregar un argumento llamado locale = '', lo que hace este argumento como ya lo has de suponer es definir el idioma, cada idioma tiene su propio código por ejemplo en el caso del inglés es "en".

- Class: text
  Output: Si no sabes cuál es el tuyo simplemente buscalo en internet.

- Class: mult_question
  Output: Una ultima practica para pasar a lo siguiente. Supon que quieres extraer la letra central de un conjunto de palabras, que funciones usarías en el caso de las palabras que tienen un número par de letras si te dicen que te tomes las dos letras centrales dadas las siguientes opciones.
  AnswerChoices: str_to_title y str_sub;if y str_subset;if y str_sub;str_to_title
  CorrectAnswer: if y str_sub
  AnswerTests: omnitest(correctVal='if y str_sub')
  Hint: Revisa que hace cada función.

- Class: text
  Output: Buscando patrones con expresiones regulares

- Class: text
  Output: Las expresiones regulares son una herramienta que nos ayuda a encontrar patrones dentro de los strings.

- Class: text
  Output: Las primeras expresiones que utilizaremos son str_view y str_view_all.

- Class: text
  Output: Las anteriores reciben como argumentos

- Class: text
  Output: un string o conjunto de strings

- Class: text
  Output: el patrón que se desea encontrar

- Class: text
  Output: Veamos un ejemplo práctico.

- Class: cmd_question
  Output: Aplica la función str_view con el siguiente código str_view(color, "a")
  CorrectAnswer: str_view(color, "a")
  AnswerTests: omnitest(correctExpr='str_view(color, "a")')
  Hint: Escribe el código que se te proporciono.

- Class: text
  Output: Existen caracteres especiales que se usan para busquedas un poco más avanzadas por ejemplo cuando quieres que R busque cualquier caracter se utiliza un "." es decir digamos que quieres todas las palabras que tengan una a entre la segunda y la penúltima letra debes usar ".a."

- Class: text
  Output: Te preguntarás que pasa cuando quieres buscar uno de estos caracteres de manera particular, es curioso por que también existe un caracter especial para estos casos. 

- Class: text
  Output:  Este símbolo es "\\" , dando un ejemplo justo de lo anterior para buscar el punto se escribiría "\\."

- Class: text
  Output: Surge una duda natural, entonces como busco \ es lógico pensar que bastaría con tres diagonales pero como la "\" tiene la misma función que "\\" pero para las expresiones regulares de los strings, se deben utilizar cuatro diagonales para poder buscar una "\\\\"

- Class: text
  Output: Ahora veremos enrutamientos, mejor conocidos como "Anchors".

- Class: text
  Output: Normalmente cuando utilizas una expresión regular hace una busqueda de cualquier carácter que concuerde.

- Class: text
  Output: Los anchors resultan muy útiles porque puedes hacer que la condición concuerde con el inicio o el final de los strings a los que les estás aplicando la busqueda.

- Class: text
  Output: Para que concuerde con el inicio de los strings se utiliza el símbolo "^".

- Class: text
  Output: Para que concuerde con el final de los strings se utiliza el símbolo "$".

- Class: text
  Output: Hagamos una practica para que puedas aplicar lo que acabas de aprender.

- Class: cmd_question
  Output: Manda llamar el vector color para que recuerdes su estructura.
  CorrectAnswer: color
  AnswerTests: omnitest(correctExpr='color')
  Hint: Escribe "color" para mandarlo llamar. 

- Class: cmd_question
  Output: Ahora que los viste aplica la función str_view y busca los colores que comienzan con la letra "A".
  CorrectAnswer: str_view(color, "^A")
  AnswerTests: omnitest(correctExpr='str_view(color, "^A")')
  Hint: Recuerda poner la letra tal y como viene en el string. EL código correcto es str_view(color, "^A")

- Class: cmd_question
  Output: Ahora aplica la misma función pero busca los colores que terminen con "o".
  CorrectAnswer: str_view(color, "o$")
  AnswerTests: omnitest(correctExpr='str_view(color, "o$")')
  Hint: Debes utilizar el símbolo $

- Class: text
  Output: Pero que pasa cuando se trata de un lista muy larga, en algunos casos es más eficiente que sólo te muestre los strings que cumplem con el patrón deseado, para eso se agrega un argumento a str_view() llamado match, el mismo lo definirás como "match = TRUE".

- Class: text
  Output: Ya has visto caracteres especiales que sirven para identificar más de un caracter, ahora veremos a otros cuatro de ellos que pueden resultar muy útiles.




- Class: text
  Output: \d que sirve para buscar cualquier dígito.

- Class: text
  Output: \s que sirve para buscar espacios en blanco.





- Class: text
  Output: el siguiente son corchetes de tipo []

- Class: text
  Output: Que si se introducen caracteres separados por comas, r buscará todos los strings que contengan alguno de los mismos.

- Class: text
  Output: Si quiere excluir esos caracteres de una busqueda general simplemente añade este símbolo "^" antes del primer carácter

- Class: text
  Output: Es importane recordar que para poder usar cualquier expresión que tenga una diagonal invertida la incio "\" se debe añadir otra diagonal para evitar que se genere un error.


- Class: text
  Output: Es posible utilizar expresiones lógicas como "o" mejor conocido como "OR" que se denota por "|".


- Class: cmd_question
  Output: Digamos que tienes el vector c("tomo", "tome", "temía", "temerá") y quieres que encuentre las primeras dos de la lista. Utilizá un "or". 
  CorrectAnswer: str_view(c("tomo", "tome", "temía", "temerá"), "tom(o|e)")
  AnswerTests: omnitest(correctExpr='str_view(c("tomo", "tome", "temía", "temerá"), "tom(o|e)")')
  Hint: El código correcto es str_view(c("tomo", "tome", "temía", "temerá"), "tom(o|e)").

- Class: text
  Output: Repeticiones.

- Class: text
  Output: y con repeticiones queremos decir controlar que número de coincidencias que se deben buscar.

- Class: text
  Output: Existen varios caracters que se pueden utilizar para esto.


- Class: text
  Output: Un signo de interrogación (final) sirve para buscar cero o una.

- Class: text
  Output: Un signo de más para buscar uno a más coincidencias.

- Class: text
  Output: Un signo de multiplicación para buscar cero o más. 


- Class: cmd_question
  Output: Tienes el vector color y quieres el patrón A seguido de algún caracter
  CorrectAnswer: str_view(color, "A*")
  AnswerTests: omnitest(correctExpr='str_view(color, "A*")')
  Hint: Utiliza A*.

- Class: text
  Output: Para que quede más claro haremos un ejercicio más con repeticiones.

- Class: mult_question
  Output: Supón que tienes el vector x <- "aaaaaa" y corres el código str_view(x, "a*"). Cuál será el resultado.
  AnswerChoices: Todas las a son seleccionadas;Ninguna letra es seleccionada, el patŕon no coincide;Se selecciona sólo la primera letra
  CorrectAnswer: Todas las a son seleccionadas
  AnswerTests: omnitest(correctVal='Todas las a son seleccionadas')
  Hint: Recuerda que hace cada símbolo.

- Class: text
  Output: Muy bien, al poner el signo "*" le indicamos a R que busque repeticiones del patŕon en cada string. Por eso es que señala todas las letras.

- Class: text
  Output: Aun que también puedes determinar el número de repeticiones que quieres que R busque en cada string.

- Class: text
  Output: /{n}/ Se usa para indicar que quieres que lo busque n veces.(Ignora las diagonales)

- Class: text
  Output: /{n,}/ le indica a R que debe de buscar mínimo n repeticiones por string. (Ignora las diagonales)

- Class: text
  Output: /{,n}/ le indica a R que debe de buscar máximo n repeticiones por string. (Ignora las diagonales)

- Class: text
  Output: /{n,m}/ le indica a R que debe de buscar entre n y m repeticiones por string. (Ignora las diagonales)

- Class: text
  Output: Hagamos un ejercicio con el vector x .

- Class: cmd_question
  Output: Utiliza la función str_view() y lo que acabas de ver para que sólo busque tres patrones por string. En este caso el patrón sigue siendo "a"
  CorrectAnswer: str_view(x, "a{3}")
  AnswerTests: omnitest(correctExpr='str_view(x, "a{3}")')
  Hint: La respuesta correcta es str_view(x, "a{3}")

- Class: text
  Output: Como pudiste ver sólo señalo tres letras de x.
