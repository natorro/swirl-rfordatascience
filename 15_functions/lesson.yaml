- Class: meta
  Course: swirl-rfordatascience
  Lesson: 15_functions
  Author: your name goes here
  Type: Standard
  Organization: your organization's name goes here
  Version: 2.4.3
  
- Class: text
  Output: En esta lección aprenderas a escribir funciones para automatizar tareas en el copiado y pegado de datos.

- Class: text
  Output: Las ventajas de crear funciones se pueden resumir en(:)

- Class: text
  Output: Puedes renombrar la función de manera personalizada para hacer de tu codigo uno mas legible y facil de entender, llamando una función que recorre un archivo como lectura() por ejemplo.

- Class: text
  Output: Para cuestiones de requisitos de cambios cuando se trabaja con un equipo en un programa, puedes llevar a cabo los cambios en un solo lugar, en vez de multiples lineas.

- Class: text
  Output: Eliminas la probabilidad de errores en el copiado y pegado que un humano pueda cometer si no usas la recursividad de las funciones.

- Class: text
  Output: La mejor forma de saber si necesitas de una función es cuando tienes dos o mas tareas ejecutandose en tu codigo que hacen exactamente lo mismo, o hacer una acción de manera recursiva en varios objetos a la vez, como sumas, restas, conversiones de datos, etc. 

- Class: text
  Output: Una clave para empezar a transformar codigo en una función es evaluar cuantas entradas y salidas contienen, reemplazandolas por variables temporales con nombres generales, para poder identificar las entradas y salidas.

- Class: text
  Output: Hay 3 pasos clave para transformar un código en una función(:)

- Class: text
  Output: 1. Escoger un nombre para la función, que sea descriptivo de lo que el código lleva a cabo de manera corta y concisa.

- Class: text
  Output: 2. Un listado de las entradas o argumentos de entrada que seran procesados dentro de la función, pueden ser uno o varios argumetos.

- Class: text
  Output: 3. Pones el codigo que has desarrollado en el cuerpo de la función entre {}

- Class: text
  Output: Veamos un ejemplo sencillo en el que tendrías que repetir código para completar la taréa.

- Class: cmd_question
  Output: Crea un data frame con el siguiente código df <- data.frame(a = c(1:5), b = c(4:8))
  CorrectAnswer: df <- data.frame(a = c(1:5), b = c(4:8))
  AnswerTests: omnitest(correctExpr='df <- data.frame(a = c(1:5), b = c(4:8))')
  Hint: Usa el código que se te proporcionó.

- Class: cmd_question
  Output: Escribe df para que visualices el data frame.
  CorrectAnswer: df
  AnswerTests: omnitest(correctExpr='df')
  Hint: Escribe df.

- Class: text
  Output: El problema es que te piden que los valores estén en números decimales.

- Class: text
  Output: Una forma de hacerlo sería por columnas.

- Class: text
  Output: df$a <- df$a / 10

- Class: text
  Output: df$b <- df$b / 10

- Class: text
  Output: Se ve muy sencilla pero que pasa cuando tienes un gran número de columnas

- Class: text
  Output: 1 El error humano es decir que te equivoques al copiar y pegar.

- Class: text
  Output: 2 No es nada eficiente que estes copiando, pegando y mdoficando código para cada columna.

- Class: text
  Output: Ahora generaremos una función para hacer más rápido el proceso.





- Class: script
  Output: Escribe le siguiente código, decimal <- function(x) { for (i in seq_along(x)) { x[i] <- x[[i]] / 10  }; x}
  AnswerTests: omnitest(correctExpr='decimal <- function(x) { for (i in seq_along(x)) { x[i] <- x[[i]] / 10  }; x}')
  Hint: Escribe lo que se te pidió.
  Script: function1.R








- Class: cmd_question
  Output: Escribe el siguiente código decimal <- function(x) { for (i in seq_along(x)) ( x[i] <- x[[i]] / 10) x }
  CorrectAnswer: decimal <- function(x) { for (i in seq_along(x)) ( x[i] <- x[[i]] / 10) x }
  AnswerTests: omnitest(correctExpr='decimal <- function(x) { for (i in seq_along(x)) ( x[i] <- x[[i]] / 10) x }')
  Hint: Escribe lo que se te pidió.



- Class: cmd_question
  Output: Type your text output here.
  CorrectAnswer: decimal(df)
  AnswerTests: omnitest(correctExpr='decimal(df)')
  Hint: Type a hint.



- Class: text
  Output: Como podrás ver se modificó la dataframe y ahora tiene puros valores en decimal.

- Class: text
  Output: Es importante recalcar que no hay una fórmula que te diga exactamente que hacer para crear la función que necesitas.

- Class: text
  Output: Por que no existe una solución única.

- Class: text
  Output: Por lo tanto deberás practicar para que desarrolles tu intución y seas capaz de crear las funciones que necesites.

- Class: text
  Output: Lo ejemplificaremos con otra función que hace lo mismo que la anterior.

- Class: cmd_question
  Output: Utiliza el siguiente código decimal2 <- function(x) { for (i in 1:length(x)){ x[i] <- x[i] /10 } x }
  CorrectAnswer: decimal2 <- function(x) { for (i in 1:length(x)){ x[i] <- x[i] /10 } x }
  AnswerTests: omnitest(correctExpr='decimal2 <- function(x) { for (i in 1:length(x)){ x[i] <- x[i] /10 } x }')
  Hint: Utiliza el código que se te proporcionó.

- Class: cmd_question
  Output: Aplica la función decimal2 en df.
  CorrectAnswer: decimal2(df)
  AnswerTests: omnitest(correctExpr='decimal2(df)')
  Hint: Escribe decimal2(df).

- Class: text
  Output: Podrás ver que arrojó el mismo resultado.




- Class: text
  Output: Al nombrar las funciones debes tener encuenta que la computadora no es la única que va a leer tú código por lo que debe ser entendible tanto para ti como para otros humanos.

- Class: text
  Output: Es preferible que utilices una sóla palabra pero si te parece más entendible poniendole más palabras procura separarlas con un guión bajo o que cada palabra comience con mayúscula.

- Class: text
  Output: No importa que forma de nombrar a las funciones elijas, lo que si importa es que seas consistente y cada función que hagas la nombres con el mismo formato.

- Class: text
  Output: Es importane por que vuelve tu código más legible.

- Class: text
  Output: Ahora si tienes un familia de funciones que hacen cosas similares o sirven al mismo objetivo es importante que haya consistencia tanto en sus nombres como en sus argumentos.

- Class: text
  Output: Por ejemplo

- Class: text
  Output: tienes las funciones

- Class: text
  Output: make_mult()

- Class: text
  Output: make_sum()

- Class: text
  Output: make_fact()

- Class: text
  Output: Sí en algún momento olvidas el nombre de la función que necesitas, todo será tan simple como escribir make y gracias al autocompletado podrás ver las funciones disponibles.

- Class: text
  Output: R ya tiene muchas funciones tanto en sus base como en las paqueterías por lo que te recomendamos que antes de hacer una función verifiques si no existe en alguna de las opciones anteriores.

- Class: text
  Output: Algo que puede ser muy útil tanto para ti como para las personas que vean tú código es comentarlo.

- Class: text
  Output: Así podrás explicar paso por paso lo que hace o poner palabras clave para que no tengas confución alguna.

- Class: text
  Output: Es tan simple como poner el signo de # y escribir lo que desees.

- Class: text
  Output: Ahora veremos condicionales

- Class: text
  Output: Cuando comiences a generar código más complejo muchas veces querrás que dependiendo del valor de cierta condición (Que tu vas a definir) se ejecute una u otra parte del código.

- Class: text
  Output: Bueno esto lo vas a hacer con condicionales.

- Class: text
  Output: Un condicional en r se declara como un 

- Class: text
  Output: if (condición) {#Código a ejecutar si la condición es verdadera} else {#Código a ejecutar si la condición es falsa}

- Class: text
  Output: Veamos  una función muy sencilla como ejemplo

- Class: text
  Output: Nuestra función recibirá la medida de dos lados con intersección en una figura geométrica y nos dirá si se trata de un rectángulo o de un cuadrado.

- Class: cmd_question
  Output: Escribe el siguiente código, tipoFig <-function(a,b) { if(a == b) {print("Es un cuadrado")} else { print( "Es un rectángulo")}}
  CorrectAnswer: tipoFig <-function(a,b) { if(a == b) {print("Es un cuadrado")} else { print( "Es un rectángulo")}}
  AnswerTests: omnitest(correctExpr='tipoFig <-function(a,b) { if(a == b) {print("Es un cuadrado")} else { print( "Es un rectángulo")}}')
  Hint: Utiliza el código que se te proporcionó.

- Class: text
  Output: La condición debe ser evaluada como verdadera o falsa.

- Class: text
  Output: En caso de que utilices un vector como condición te arrojará un mensaje de warning advirtiendote que sólo tomará el primer valor del vector como condición.

- Class: text
  Output: Tampoco podrás poner NA como la única condición por que esto dará error al ser ejecutado.

- Class: text
  Output: Habrá casos en los que quieras poner más de una condición, afortunadamente existe una herramienta para esto.

- Class: text
  Output: Se utiliza || para referirse a un or.

- Class: text
  Output: Se utiliza & para referirse a un and.

- Class: text
  Output: Estos puedes usarlos para crear multiples expresiones lógicas.

- Class: text
  Output: Es importante que que tengas cuidado con la lógica de tus expresiones para que las condiciones funcionen de la manera correcta. Hagamos un ejercicio para ejemplificar un clásico error.



- Class: text
  Output: Para que no hay dudas veremos congruencias (con 0) como nota rápida.

- Class: text
  Output: En matemáticas un número tiene congruencia 0 con otro si al dividir el primero por el segundo se tiene residuo 0.

- Class: text
  Output: Es decir si hicieras x congruente con 2 y lo aplicaras a los números naturales ( cero a infinito) todos los números pares cumplirían la condición.

- Class: text
  Output: En R congruencia es representada por %%.

- Class: text
  Output: Vamos al ejercicio.

- Class: mult_question
  Output: Sí te doy la siguiente condición if ((x %% 2 == 0 || x %% 3 == 0) & (x %% 7 == 0)) {} y el vector b = c(2, 3, 4, 5, 6, 7, 8). ¿Qué números cumplen?
  AnswerChoices: (2, 3, 4, 6, 7, 8);(2, 3, 7);(7);(ninguno)
  CorrectAnswer: (ninguno)
  AnswerTests: omnitest(correctVal='(ninguno)')
  Hint: Revisa las implicaciones.

- Class: text
  Output: Un poco engañoso no?

- Class: text
  Output: Tienes dos condiciones pero al tener el & entre ellas obliga a que las dos se cumplan para que obtener un verdadero.

- Class: mult_question
  Output: Ahora con está condición if ((x %% 2 == 0 || x %% 7 == 0) & (x %% 7 == 0)) {} y el vector b = c(2, 3, 4, 5, 6, 7, 8). ¿Qué números cumplen?
  AnswerChoices: (2, 4, 6, 7, 8);(2, 7);(7);(ninguno);(todos)
  CorrectAnswer: (7)
  AnswerTests: omnitest(correctVal='(7)')
  Hint: Utiliza la lógica del ejercicio anterior.



- Class: text
  Output: Bien hecho, al tener un or en la primera condición admitía congruentes tanto con dos como con 7 pero al aplicar las segunda condición el único valor que cumple es el 7.

- Class: text
  Output: Ahora veremos condiciones multiples.

- Class: text
  Output: Estas son muy útiles cuando quieres que cuando los valores cumplan distintas condiciones se les apliquen distintas operaciones.

- Class: text
  Output: La estructura es de la siguiente forma.

- Class: text
  Output: if (condición1) {acción1} else if (acción2) {} else { otra acción}

- Class: text
  Output: Claro que va con sus saltos de línea y espacios correspondientes.

- Class: text
  Output: Ten cuidado por que las condiciones se aplican de manera ordenada así que trata de poner las más específicas al incio para que los datos se vayan a la condición que deseas.

- Class: text
  Output: Veamos un ejemplo.

- Class: text
  Output: Sí tu pones el siguiente código.

- Class: text
  Output: if (x %% 2 == 0) {} else if (x %% 2 & x %% 3){} else {}

- Class: text
  Output: Todos los números congruentes con 2 van a entrar en el primer if siendo que en el segundo podrían entrar algunos de ellos, entonces no tendría ningun sentido tener el primer argumento del segundo if. Pero si intercambian sus argumentos el primer y el segundo if entonces se tomarían los valores  de la manera correcta y ya no habría incongruencias.

- Class: text
  Output: Cuando se tienen demasiadas condiciones por separado se vuelve tedioso tener demasiados if's pero no te preocupes por que R tiene una herramienta para eso.

- Class: text
  Output: Se llama switch() y funciona como uno.
