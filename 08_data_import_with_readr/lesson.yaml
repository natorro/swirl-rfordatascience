- Class: meta
  Course: swirl-rfordatascience
  Lesson: 08_data_import_with_readr
  Author: your name goes here
  Type: Standard
  Organization: your organization's name goes here
  Version: 2.4.3

- Class: text
  Output: En este capitulo aprenderas a leer archivos de texto plano en R usando las propiedades de importar datos.

- Class: cmd_question
  Output: Como es costumbre, iniciaremos por cargar la biblioteca de Tidyverse. Ejecuta el código necesario para ello.
  CorrectAnswer: library(tidyverse)
  AnswerTests: omnitest(correctExpr='library(tidyverse)')
  Hint: usa la función library()

- Class: text
  Output: la función de readr's es la de convertir textos planos en data frames, teniendo como conjunto de funciones a read_csv() y read_csv2() que se diferencian en el cómo estan separados los valores, si por coma o por semicolon respectivamente.

- Class: text
  Output: read_tsv() lee archivos delimitados por tabuladores, y read_delim() lee archivos con cualquier delimitante, lo cual la convierte en la función mas flexible para leer archivos.

- Class: text
  Output: read_fwf() lee archivos con un ancho fijo, los cuales se pueden especificar en campos con fwf_widths() o ayudar a encontrar su posición con fwf_positions(). 

- Class: text
  Output: read_log() lee archivos de estilo apache o webreadr.

- Class: text
  Output: Para poder usar read_csv(), debes entender que la parte crucial para que funcione se encuentra en la dirección que usas para ubicar un archivo a leer, y que esta lectura la puedes asignar a  un data frame. Esto lo logras poniendo la dirección del directorio donde se encuentra el archivo dentro de la función.
  
- Class: cmd_question
  Output: El csv que vamos a usar en la lección se encuentra alojado en un objeto llamado "direccion", es necesario que uses la función print() en este objeto
  CorrectAnswer: print(direccion)
  AnswerTests: omnitest(correctExpr='print(direccion)')
  Hint: Usa print(direccion)

- Class: cmd_question
  Output: A la ubicación que se te mostro anteriormente, la completaremos con el nombre del archivo profesores.csv para poder cargarlo. Para ello usaremos la función file.path() con el objeto direccion seguido del nombre del archivo csv y guardaremos la dirección en un objeto llamado "direccion_completa"
  CorrectAnswer: direccion_completa <- file.path(direccion, "profesores.csv")
  AnswerTests: omnitest(correctExpr='direccion_completa <- file.path(direccion, "profesores.csv")')
  Hint: Usa el código direccion_completa <- file.path(direccion, "profesores.csv")

- Class: cmd_question
  Output: Lee el archivo profesores.csv usando la funcion read_csv() en el objeto "direccion_completa" y guardalo dentro de un data frame llamado "profesores". Toma en cuenta que dentro del código que uses mas adelante puedes usar la dirección completa de la ubicación de tu archivo en lugar del objeto
  CorrectAnswer: profesores <- read_csv(direccion_completa)
  AnswerTests: omnitest(correctExpr='profesores <- read_csv(direccion_completa)')
  Hint: Usa profesores <- read_csv(direccion_completa)

- Class: text
  Output: Cada vez que usas la fucnión read_csv() se te mostrará un mensaje que contiene el nombre y tipo de columna que se creo dentro del data frame.

- Class: text
  Output: Algo interesante que puedes lograr con la función read_csv() es leer un csv sin tener que ingresar un archivo.

- Class: cmd_question
  Output: Intenta crear uno, usa el siguiente arreglo de caracteres para crear un csv desde la función read_csv(), "a, b, c\n5, 8, 3\n9, 3, 7"
  CorrectAnswer: read_csv("a, b, c\n5, 8, 3\n9, 3, 7")
  AnswerTests: omnitest(correctExpr='read_csv("a, b, c\n5, 8, 3\n9, 3, 7")')
  Hint: Usa el codigo read_csv("a, b, c\n5, 8, 3\n9, 3, 7")

- Class: text
  Output: read_csv() usa la primera fila de los datos que se encuentran en el csv como los nombres para las columnas, lo cual es una convención muy comun; pero en algunos casos la primera fila de los archivos estan llenos de datos que no corresponden con el nombre o con datos que queremos extraer, por lo que es de gran ayuda que exista el atributo skip = n, el cual te permite saltar n numero de lineas e iniciar la lectura en la inea inmediata

- Class: text
  Output: Tambien existe comment = "#", el cual permite comentar las lineas que empiezen con el caracter que especifiques

- Class: text
  Output: Si los datos no tienen nombre de columna, puedes usar col_names = FALSEpara indicarle a la funcion read_csv() que no trate a la primera linea como encabezados, si no que los trate bajo el nombre de X1 a Xn

- Class: cmd_question
  Output: Intentemos realizar un ejemplo de read_csv() sin nombres, usando el arreglo "1,2,3\n4,5,6" y asignando el valor FALSE a col_names
  CorrectAnswer: read_csv("1,2,3\n4,5,6", col_names = FALSE)
  AnswerTests: omnitest(correctExpr='read_csv("1,2,3\n4,5,6", col_names = FALSE)')
  Hint: Usa el codigo read_csv("1,2,3\n4,5,6", col_names = FALSE)

- Class: text
  Output: Tambien puedes usar un vector con los nombres de las columnas cuando requieras de mantenerlos separados y organizados

- Class: cmd_question
  Output: usemos el atributo col_names = c(), donde a c() le corresponderian los nombres ("gatos", "perros", "peces"), para los datos "65, 26, 83\n93, 23, 92" en la función read_csv()
  CorrectAnswer: read_csv("65, 26, 83\n93, 23, 92", col_names = c("gatos", "perros", "peces"))
  AnswerTests: omnitest(correctExpr='read_csv("65, 26, 83\n93, 23, 92", col_names = c("gatos", "perros", "peces"))')
  Hint: La respuesta es read_csv("65, 26, 83\n93, 23, 92", col_names = c("gatos", "perros", "peces"))


- Class: text
  Output: En algunas ocasiones, existe un formato para indicar que un espacio en tu csv esta vacio, para indocarle esto a R y que los tome como vacios puedes usar el atributo na = "", donde puedes indicarle que trate a todos los espacios que encuentre con esa definicion como nulos

- Class: cmd_question
  Output: lee el output del código read_csv("Bebida,papas,hamburguesa\nSi,.,Si\n.,.,Si\nSi,.,.\nSi,Si,Si", na = ".") y verifica en que convirtio los registros que contenian .
  CorrectAnswer: read_csv("Bebida,papas,hamburguesa\nSi,.,Si\n.,.,Si\nSi,.,.\nSi,Si,Si", na = ".")
  AnswerTests: omnitest(correctExpr='read_csv("Bebida,papas,hamburguesa\nSi,.,Si\n.,.,Si\nSi,.,.\nSi,Si,Si", na = ".")')
  Hint: solo copia read_csv("Bebida,papas,hamburguesa\nSi,.,Si\n.,.,Si\nSi,.,.\nSi,Si,Si", na = ".")

- Class: text
  Output: Todos los modos en que puedes emplear read_csv() que mostramos durante el curso se pueden adaptar a las funciones de lectura de otras extensiones de archivo, como readtsv() y read_fwf(). 

- Class: text
  Output: ¿Como es que hasta el momento usamos read_csv() sobre la función base de read.csv() en R? Muy simple, es mas ventajoso en las siguientes cualidades(:)

- Class: text
  Output: La velocidad de procesamiento de la función de lectura de tidyverse llega a ser 10 veces mas veloz, y muestra una barra indicadora del progreso del proceso

- Class: text
  Output: Produce tibbles, los cuales te protegen de errores comunes en la función base de R, y te salva de varias frustraciones con la conversión de tipos de datos.

- Class: text
  Output: La función de tidyverse es independiente del equipo que estes utilizando, a diferencia de su contraparte, que toma algunos recursos y depende de la configuración de algunos equipos donde se ejecute, por lo que nos ofrece mas portabilidad en código.
  

- Class: text
  Output: Ahora bien, para sacar provecho de la funcionalidad de lectura, necesitas aprender a usar las funciones parse_*(), lo cual se puede traducir a funciones que convierten datos a un tipo de dato especifico, añadiendo propiedades lógicas, de caracteres especiales, agrupación exclusiva de numeros o conversión a fechas.

- Class: cmd_question
  Output: Como ejemplo convertiremos una serie de cadenas descriptivas del orden en que se aplica el tipo de dato booleano; para ello ejecuta la siguiente linea de código(:) str(parse_logical(c("TRUE", "FALSE", "NA")))
  CorrectAnswer: str(parse_logical(c("TRUE", "FALSE", "NA")))
  AnswerTests: omnitest(correctExpr='str(parse_logical(c("TRUE", "FALSE", "NA")))')
  Hint: ingresa el código str(parse_logical(c("TRUE", "FALSE", "NA")))

- Class: text
  Output: Como te habras dado cuenta, el resultado de la ejecución del codigo es una linea que inicia con logi, el cual indica que se aplicó el tipo de dato lógico a la cadena, en el orden especificado(:) TRUE, equivalente a 1, FALSE correspondiente a 0 y NA, que declara vacio, pero estas ya no son solo cadenas, si no que ademas indican un estado booleano al usarse. 

- Class: text
  Output: Si por alguna razón falla la conversión a tipo de dato de una serie de cadenas a, por ejemplo, números enteros, y entre las cadenas se encuentran letras, la función te devolvera un mensaje de error indicando que datos fueron imposibles de convertir, debido a que conflictuan con la definición del tipo de dato al que pretendias convertirlos.

- Class: cmd_question
  Output:     Para testear el error, intenta convertir el arreglo c("75", "465", "número", "24", "veinticinco") a números enteros con la función parse_integer(), guardandolos en un dataframe llamado enteros
  CorrectAnswer: enteros <- parse_integer(c("75", "465", "número", "24", "veinticinco"))
  AnswerTests: omnitest(correctExpr='enteros <- parse_integer(c("75", "465", "número", "24", "veinticinco"))')
  Hint: Recuerda que para guardar en un data frame el resultado de una operación se utiliza enteros <-
